// Package glogr implements github.com/thockin/logr.Logger in terms of
// github.com/golang/glog.
package stdlogr

import (
	"runtime"

	"log"

	"github.com/bketelsen/logr"
	"github.com/surge/glog"
)

// New returns a logr.Logger which is implemented by glog.
func New() (logr.Logger, error) {
	return logger{
		level:  0,
		prefix: "",
	}, nil
}

type field struct {
	name  string
	value interface{}
}
type logger struct {
	level  int
	prefix string
	fields []field
}

func prepend(level string, prefix interface{}, args []interface{}) []interface{} {
	return append([]interface{}{level, prefix}, args...)
}

// Magic string for intermediate frames that we should ignore.
const autogeneratedFrameName = "<autogenerated>"

// Discover how many frames we need to climb to find the caller. This approach
// was suggested by Ian Lance Taylor of the Go team, so it *should* be safe
// enough (famous last words).
func framesToCaller() int {
	// 1 is the immediate caller.  3 should be too many.
	for i := 1; i < 3; i++ {
		_, file, _, _ := runtime.Caller(i + 1) // +1 for this function's frame
		if file != autogeneratedFrameName {
			return i
		}
	}
	return 1 // something went wrong, this is safe
}

func (l logger) Info(args ...interface{}) {
	if l.Enabled() {
		if fs, ok := l.fieldString(); ok {
			args = append(args, fs)
		}
		log.SetPrefix(l.prefix)
		log.Println(args...)
	}
}

func (l logger) Infof(format string, args ...interface{}) {
	if l.Enabled() {
		if fs, ok := l.fieldString(); ok {
			args = append(args, fs)
		}
		log.SetPrefix(l.prefix)
		log.Printf("%s %v", args...)
	}
}

func (l logger) Enabled() bool {
	return bool(glog.V(glog.Level(l.level)))
}

func (l logger) Error(args ...interface{}) {
	if fs, ok := l.fieldString(); ok {
		args = append(args, fs)
	}
	log.SetPrefix(l.prefix)
	log.Println(args...)
}

func (l logger) Errorf(format string, args ...interface{}) {

	if fs, ok := l.fieldString(); ok {
		args = append(args, fs)
	}
	log.SetPrefix(l.prefix)
	log.Printf("%s %v", args...)
}

func (l logger) V(level int) logr.InfoLogger {
	return logger{
		level:  level,
		prefix: l.prefix,
	}
}

func (l logger) NewWithPrefix(prefix string) logr.Logger {
	return logger{
		level:  l.level,
		prefix: prefix,
	}
}

func (l logger) WithField(name string, value interface{}) logr.Logger {
	return logger{
		level:  l.level,
		prefix: l.prefix,
		fields: append(l.fields, field{name: name, value: value}),
	}
}

func (l logger) fieldString() (string, bool) {
	if len(l.fields) > 0 {
		var buf []byte
		buf = append(buf, '[')
		for _, f := range l.fields {
			buf = append(buf, []byte(toString(f.name))...)
			buf = append(buf, []byte(":")...)
			buf = append(buf, []byte(toString(f.value))...)
			buf = append(buf, ' ')
		}

		buf = append(buf, ']')
		return string(buf), true
	}
	return "", false
}

var _ logr.Logger = logger{}
var _ logr.InfoLogger = logger{}
